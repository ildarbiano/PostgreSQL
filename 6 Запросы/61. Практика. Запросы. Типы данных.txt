======================== типы данных
postgres=# select count(*) from pg_type;
 count
-------
   625								-- количество типов данных в Postgres
(1 row)

========================Разница между PROCEDURE и FUNCTION:
Аспект			PROCEDURE					FUNCTION
Возврат			Не возвращает значение (или через OUT)		Возвращает значение
Вызов			CALL proc_name()				SELECT func_name()
В транзакции		Может завершать транзакции			Не может
Создание		PostgreSQL 11+					Все версии

-------------------------------------------
CREATE or REPLACE PROCEDURE p(inout x text)			-- создания хранимой процедуры (процедуру, а не функцию) в PostgreSQL. p — имя процедуры. Процедуры, способные управлять транзакциями и вызываться через CALL, с одним INOUT параметром типа text.
as $$								-- $$ или ' — разделители тела процедуры (dollar quoting)
    DECLARE 							-- секция в процедуре PL/pgSQL объявляет локальные переменные. Это блок объявления локальных переменных, которые будут доступны только внутри этой процедуры.
       i INTEGER DEFAULT 1;					-- i — имя переменной. INTEGER — тип: целое число (4 байта, от -2⁷³ до 2⁷³-1). INTEGER (целые числа). DEFAULT 1 — начальное значение = 1
       d DECIMAL(10,4) DEFAULT 0;				-- d — имя переменной. DECIMAL(10,4) — тип: десятичное число с фиксированной точностью. DECIMAL/NUMERIC (точные числа) 10 — общее количество цифр. 4 — количество цифр после запятой. Пример: 123456.7890 (6 цифр до, 4 после). DEFAULT 0 — начальное значение = 0.0000
       f FLOAT DEFAULT 0;					-- f — имя переменная. FLOAT — тип: число с плавающей точкой (обычно 8 байт). FLOAT/REAL (приближенные числа). Синонимы: REAL (4 байта), DOUBLE PRECISION (8 байт). DEFAULT 0 — начальное значение = 0.0
  BEGIN								-- BEGIN ... END; — тело процедуры
      LOOP  
          d := d + 0.001;					-- : = (альтернатива). оператор присваивания
          f := f + 0.001E0;
          i := i + 1;
          if i > 10000 
            then exit; 
          end if; 
    END LOOP;
    x := d::text || ' ' || f::text;				-- Процедура выполняет цикл, вычисляет значения d и f, затем объединяет их в строку x. Числовые типы нужно явно преобразовывать в текст с помощью ::text. Для конкатенации строк используется оператор ||. Конкатенация — это склеивание или объединение строк (текста) в одну.
     end;
$$								-- $$ — закрывающий разделитель
language plpgsql 						-- язык процедуры (PL/pgSQL)
;
--------
postgres=# CREATE or REPLACE PROCEDURE p(inout x text)
as $$
    DECLARE
       i INTEGER DEFAULT 1;
       d DECIMAL(10,4) DEFAULT 0;
       f FLOAT DEFAULT 0;
  BEGIN
      LOOP
          d := d + 0.001;
          f := f + 0.001E0;
          i := i + 1;
          if i > 10000
            then exit;
          end if;
    END LOOP;
     x := d::text || ' ' || f::text;				
     end;
$$
language plpgsql
;
CREATE PROCEDURE
postgres=# call p('');						-- вызов процедуры
             x
---------------------------
 10.0000 9.999999999999897					-- демонстрирует разницу между точной (decimal) и приближенной (float) арифметикой в PostgreSQL!
(1 row)
Для DECIMAL(10,4):
	Используется точная десятичная арифметика
	0.001 точно представляется в decimal
	0.001 * 10000 = 10.0000 (точно)

Для FLOAT (double precision):
	Используется двоичная арифметика IEEE 754
	0.001 не представляется точно в двоичной системе (как 1/3 не представляется точно в десятичной)
	Происходит накопление ошибок округления
Результат: 9.999999999999897 вместо 10.0


=================================== ДЕНЕЖНЫЙ ТИП ДАННЫХ:
postgres=# show lc_monetary;					-- lc_monetary влияет только на тип money, не на numeric или decimal.  — это параметр локали PostgreSQL, который определяет форматирование денежных значений (тип money). Что такое lc_monetary? Это настройка, которая влияет на: Символ валюты (например, $, €, ¥, £). Разделитель групп разрядов (например, 1,000,000.00 или 1 000 000,00). Десятичный разделитель (точка или запятая). Положение символа валюты (перед или после суммы)
 lc_monetary
-------------
 C.UTF-8							-- — это локаль по умолчанию во многих системах, которая использует:
	Доллар ($) как символ валюты
	Точку '.' как десятичный разделитель
	Запятую ',' как разделитель тысяч
(1 row)







-------------------------ПРИМЕР:
Полная структура таблицы:
Столбец		Тип			Ограничения		По умолчанию
id		INTEGER			PRIMARY	KEY		из sequence
kind		TEXT			-			NULL
created_at	TIMESTAMP		-			now()
price		DECIMAL(12,2)		-			NULL
----------------------------------------------------------------------
postgres=# CREATE TABLE goods(
  id SERIAL PRIMARY KEY,					-- id - уникальный идентификатор (столбец таблицы). SERIAL - автоинкрементируемое целое число (1, 2, 3...). PRIMARY KEY - первичный ключ (уникальный, не может быть NULL). Автоматически создает последовательность goods_id_seq. SERIAL не является настоящим типом данных, это синтаксический сахар для (INTEGER + SEQUENCE). Автоинкремент - это автоматическое увеличение значения поля при каждой новой записи. Как нумерация страниц в книге - каждая следующая страница получает номер на 1 больше предыдущей.
  kind TEXT,							-- kind (столбец таблицы);
  created_at TIMESTAMP DEFAULT now(),				-- created_at (столбец таблицы). TIMESTAMP хранит дату и время без часового пояса (есть также TIMESTAMPTZ - с часовым поясом)
  price DECIMAL(12,2)						-- price (столбец таблицы). DECIMAL(12,2) идеально подходит для цен, т.к. исключает ошибки округления при вычислениях
);
CREATE TABLE							-- создадим таблицу товаров с автоинкрементным полем, видом товара, автоматической датой добавления, ценой. 


postgres=# INSERT INTO goods(kind, price) VALUES ('bananas',100.50),('apples', 75.01);
INSERT 0 2							-- добавим пару записей
 
postgres=# SELECT * FROM goods;					--
 id |  kind   |         created_at         | price
----+---------+----------------------------+--------
  1 | bananas | 2026-01-02 09:27:28.697835 | 100.50
  2 | apples  | 2026-01-02 09:27:28.697835 |  75.01
(2 rows)

 

=============================================== преобразование типов:
PostgreSQL: 	позволяет некоторые неявные преобразования
MySQL: 		очень либерален в преобразованиях
SQLite: 	тоже позволяет многое
Oracle: 	более строгий
!-всегда явно указывать типы, чтобы код был понятнее и надежнее!

----------------------------------------------- явное преобразование:
SELECT 123::text;						-- 123 в текстовый формат
SELECT 123::double precision;					--
SELECT 123::numeric(17,2);					-- 123 в "денежный" формат

-- на примере нашей таблицы
postgres=# SELECT kind || ' ' ||  price::text FROM goods;	-- формирование вывода в строку с пробелом между полем kind и price с явным преобразованием в текстовый формат.
    ?column?
----------------
 bananas 100.50
 apples 75.01
(2 rows)

----------------------------------------------- НЕявные преобразования могут скрывать ошибки:
postgres=# SELECT kind  || price FROM goods;			-- неявное (можем в самый неожиданный момент получить баги, нежданчики преобразования)
   ?column?
---------------
 bananas100.50
 apples75.01
(2 rows)

postgres=# select 123 + '123'					-- Выполняет сложение: 123 + 123 = 246 
postgres-# ;
 ?column?
----------
      246
(1 row)

Шаг за шагом:
123 	— это число 	(тип INTEGER)
'123' 	— это строка 	(тип TEXT)
PostgreSQL видит оператор + (сложение чисел)
PostgreSQL пытается понять: "Как сложить число и текст?"
PostgreSQL автоматически преобразует текст '123' в число 123
PostgreSQL умеет неявно преобразовывать некоторые типы данных:
	Текст → Число (если текст содержит только цифры)
	Число → Текст (в некоторых контекстах)
	Дата → Текст и т.д.

========================================================JSON:
postgres=# CREATE TABLE tickets(
  ticket_no TEXT,
  contact_data JSONB
);								-- 
CREATE TABLE

postgres=# INSERT INTO tickets(ticket_no, contact_data) VALUES ('0005432000987','{"phone": ["+70582584031"], "email": "volkova.alina_03101973@postgrespro.ru"}'),('0005432000988', '{"phone": ["+666662584031"], "email": "admin@aristov.tech"}');
INSERT 0 2							-- JSONB
postgres=# SELECT * FROM tickets;
   ticket_no   |                                 contact_data
---------------+-------------------------------------------------------------------------------
 0005432000987 | {"email": "volkova.alina_03101973@postgrespro.ru", "phone": ["+70582584031"]}
 0005432000988 | {"email": "admin@aristov.tech", "phone": ["+666662584031"]}
(2 rows)

 
======================== операции над элементами json:
https://postgrespro.ru/docs/postgresql/14/functions-json

-- Например
SELECT  t.ticket_no
  , t.contact_data
  , contact_data->>'phone' as phone
  , contact_data->>'email' as email
  , contact_data - 'phone' as cd_without_phone
FROM tickets as t
WHERE contact_data->>'phone' like '%+7%';


--каждый элемент JSON может быть JSON, также можно использовать массивы элементов
UPDATE tickets set contact_data = '{"phone": ["+80582584031", "+70582584031"], "email": "volkova.alina_03101973@postgrespro.ru"}' WHERE ticket_no = '0005432000987';
 

-- если больше 1 элемента в JSON, то мы дублируем основную строку + элемент json
SELECT   t.ticket_no
    , t.contact_data
    , cd.*
FROM tickets as t, jsonb_each_text(t.contact_data) as cd;
