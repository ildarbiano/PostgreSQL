=================================== 61 ТИПЫ ДАННЫХ ===================================:
https://postgrespro.ru/docs/postgresql/14/datatype
select count(*) from pg_type;					--600+, но основные типы, которые используются в 99,999% проектов:
	Числовые 	- 100, 500, 800.1530
		integer (Целое число), используется в качестве serial.
	Денежные 	- 100Р, 100 рублей 50 копеек		-- REAL нельзя использовать для денежного типа. Только DECIMAL или NUMERIC.
		decimal
	Символьные 	- ‘Иванов Иван’
		text
	Дата/время 	- ‘2022.08.08 14:54:00’
		timestamp
	Логический 	- да/нет
		boolean
----------------------------------- ЧИСЛОВОЙ тип данных:
https://postgrespro.ru/docs/postgresql/14/datatype-numeric 

----------------------------------- ДЕНЕЖНЫЙ:
https://postgrespro.ru/docs/postgresql/14/datatype-money 
https://habr.com/ru/company/tensor/blog/508038/
В Америке - округление к ближайшему четному:
1.5->2	
2.5->2	
в остальном мире к ближайшему:
1.5->2
2.5->3
SHOW lc_monetary - текущие параметры локали

----------------------------------- СИМВОЛЬНЫЙ тип данных:
https://postgrespro.ru/docs/postgresql/14/datatype-character
	- строка фиксированной длины (ограниченной);
	- строка переменной длины;
	- строка неограниченной длины 'text';

----------------------------------- ДАТА/ВРЕМЯ:
https://postgrespro.ru/docs/postgresql/14/datatype-datetime  
timestamp

----------------------------------- ЛОГИЧЕСКИЙ тип данных:
https://postgrespro.ru/docs/postgresql/14/datatype-boolean 
boolean
1 байт
состояние: 
истина 	(true, 1) или 
ложь 	(false, 0)

----------------------------------- ОПЕРАТОРЫ:

----------------------------------- тип данных JSON:
https://postgrespro.ru/docs/postgresql/14/datatype-json
JSON 			сохраняет точную копию введённого текста, но который, функции обработки, должны разбирать заново при каждом выполнении запроса. практически не используется;
JSONB 			сохраняются в разобранном двоичном формате (бинарный вид), что несколько замедляет ввод из-за преобразования, но значительно ускоряет обработку, не требуя многократного разбора текста и его сжания. Хорошо сжимает json. Поддерживает индексацию, но медленнее добавляет данные. Модное решение, если тип данных подходит под json.

------------------------------------ ПРЕОБРАЗОВАНИЕ ТИПОВ:
https://postgrespro.ru/docs/postgresql/14/typeconv 
select 123::text;
select 123::double precision;
select 123::numeric(17,2);
https://postgrespro.ru/docs/postgresql/14/functions		Функции для работы с типами данных
https://postgrespro.ru/docs/postgresql/14/functions-json	Функции и операторы JSON


=================================== 62 НОРМАЛИЗАЦИЯ ДАННЫХ ===================================:
https://habr.com/ru/articles/254773				Нормализация отношений. Шесть нормальных форм. Так как процесс проектирования БД является итерационным и заключается в последовательном переводе отношения из 1НФ (2НФ,3НФ...6НФ) в НФ более высокого порядка по определенным правилам, существуют понятия:
Нормальная форма		НФ		— требование, предъявляемое к структуре таблиц, в теории РЕляционных баз данных, для устранения избыточных функциональных зависимостей между атрибутами (полями таблиц).
Цель нормализации				- исключить избыточное дублирование данных, которое является возможной причиной аномалий, возникших при добавлении, редактировании и удалении кортежей(строк таблицы).
Первая нормальная форма		1НФ		- Отношение находится в 1НФ, если все его атрибуты являются простыми, все используемые домены должны содержать только скалярные (одиночного) значения. Не должно быть повторений строк в таблице.
Вторая нормальная форма		2НФ		- Отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут неприводимо зависит от Первичного Ключа(ПК). Не ключевой атрибут выделяем в отдельную таблицу, для возможности JOIN по одинаковой колонке.
Третья нормальная форма		3НФ		- Отношение находится в 3НФ, когда находится во 2НФ и каждый не ключевой атрибут нетранзитивно зависит от первичного ключа. Проще говоря, второе правило требует выносить все не ключевые поля, содержимое которых может относиться к нескольким записям таблицы в отдельные таблицы. Вынос в отдельную таблицу, с не ключевым атрибутом, в связи с 2НФ. Деление на несколько таблиц.


