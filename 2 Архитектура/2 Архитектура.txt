==================================== Архитектура:
Создание сервера PostgreSQL
Процесс	   | 	Роль
-----------+-------------
postgres   | 	server
-----------+-------------
Process Fork (copy/clone)
-------------------------фоновые процессы:
postgres 	bgwriter	проактивная запись "грязных страниц" из buffer cache на диск
postgres 	checkpointer	запись "грязных страниц" из buffer cache на диск при наступлении checkpoint
postgres 	autovacuum	периодический запуск autovacuum
.....		...		"грязных страниц"  — это страницы, которые были изменены и ещё не записаны на диск. Это понятие связано с работой контрольной точки (checkpoint) и процессом фоновой записи (background writer, bgwriter).
postgres 	archiver	архивация и репликация WAL
--------------
shared memory:
-------------
	-через него общение процессов с БД.
	-Process Memory, память для процессов.
	-это область памяти, которая используется для кэширования данных и кэширования логов транзакций. Она доступна всем процессам сервера PostgreSQL. PostgreSQL использует shared memory, чтобы позволить нескольким процессам одновременно получать доступ к данным. Система управления памятью на основе кэша хранит часто используемые данные в памяти, чтобы улучшить производительность запросов. 

------------------------------------ виды shared memory, используемые в PostgreSQL:
shared_memory_type      | mmap         		- Selects the shared memory implementation used for the main shared memory region. Определяет, какую реализацию общей памяти должен использовать сервер для основной области общей памяти, где хранятся буферы PostgreSQL и другие общие данные. Возможные значения: mmap (для анонимной общей памяти, выделенной с помощью mmap), sysv (для общей памяти System V, выделенной с помощью shmget) и windows (для общей памяти Windows).
shared_memory		|разделяемая память	- механизм межпроцессного взаимодействия (IPC, Inter-Process Communication), который позволяет процессам обращаться к одним и тем же данным напрямую, минуя промежуточные каналы (сокеты, файлы). Каждый процесс что-то пишет, для взаимедейчтвия с базой данных. 

Pool of shared buffers 				— основной блок общей памяти, в котором PostgreSQL буферизует страницы данных. Каждый процесс бэкенда обращается к этому блоку, чтобы читать и писать страницы данных. 
Buffer WAL (Write-Ahead Logging) 		— область общей памяти, в которой хранится копия данных лога транзакций перед записью в файл WAL. Это позволяет PostgreSQL восстанавливаться после сбоев системы без потери данных. 
Buffer commit log (CLOG) 			— область общей памяти, в которой хранятся страницы лога транзакций. 
---------------- параметры, которые контролируют работу shared memory. Например: 
shared_buffers 					— задаёт объём памяти, который PostgreSQL выделяет для буферов общей памяти. По умолчанию — обычно 128 МБ, но может быть меньше, если настройки ядра не поддерживают это. Рекомендуется устанавливать значение, которое составляет 15–25% от общего объёма оперативной памяти 
			
==================================== Пользователи:
Процесс	   | 	Роль
-----------+-------------
postgres   | 	server
-----------+-------------
Process Fork (copy/clone)
-----------+-------------
shared memory:
	   ^	
-----------^-------------backend процессы:
postgres   | 	backend		|	<<<< User 1, взаимодействует через backend process
-----------+-------------
postgres   | 	backend		|	<<<< User 2, взаимодействует через backend process
-----------+-------------
-----------+-------------
postgres   | 	backend		|	<<<< User 100 max (default). максимальное количество определяется параметром max_connections.
-----------+-------------


==================================== Буферный cash. Backend process:
-	Backend process, - обслуживающий процесс, который обрабатывает все запросы и утверждения, отправленные одним подключённым клиентом. 
-	Session Memory, память для (default 100) пользовательских сессий.
-	Взаимодействует с клиентом через одно TCP-соединение.
-	Завершается, как только клиент отсоединяется.
-	Может работать только с одной базой данных, при подключении к серверу PostgreSQL необходимо чётко указать именно ту базу данных, которая необходима.
-	Когда к серверу подключается много клиентов, для каждого из них порождается собственный обслуживающий процесс.
--------------- Параметры Backend process:
max_connections 		— определяет максимальное количество одновременных подключений к БД (по умолчанию — 100 подключений). 
work_mem 			— задаёт максимальный объём памяти, который может быть выделен обслуживающему процессу. Нулевое значение снимает ограничение. 
backend_flush_after 		— когда одним обслуживающим процессом записывается больше заданного объёма данных, сервер даёт указание ОС произвести запись этих данных в нижележащее хранилище. Это ограничивает объём «грязных» данных в страничном кеше ядра и уменьшает вероятность затормаживания при выполнении fsync в конце контрольной точки или когда ОС сбрасывает данные на диск большими порциями в фоне. 


==================================== Session:
выполняет запрос такой цепочки, которая требует времени и памяти:
Parser			-— это модуль, который анализирует синтаксис запроса SQL и преобразует его в дерево разбора, parse tree — иерархическую структуру данных, представляющую структуру запроса;
Analyser		-— анализатор запроса. Он проводит семантический анализ дерева разбора, которое генерируется парсером, и формирует Query tree — внутреннее представление оператора SQL, в котором все образующие его части хранятся отдельно; 
Rewriter		-— компонент, который оптимизирует запросы для улучшения их производительности. Он анализирует запрос и применяет различные техники оптимизации, чтобы переписать и перестроить план выполнения запроса; 
Planner			-— планировщик запросов, оптимизатор. Его задача — построить наилучший план выполнения SQL-запроса. Планировщик решает, как выполнить запрос: какой индекс задействовать, как соединить таблицы (Nested Loop, Hash Join, Merge Join), делать ли последовательное сканирование и т. д..
Executor		-— это модуль, который выполняет план выполнения запроса, созданный планировщиком (оптимизатором). Он отвечает за получение данных из механизма хранения, выполнение соответствующих операторов на основе дерева плана запроса и получение окончательных результатов запроса.



dead		Неиспользуемые в рамках незавершенных транзакций строки называются мертвыми.

==================================== VACUUM в PostgreSQL:
команда, которая очищает базу данных от «мёртвых» (неактуальных) dead строк и освобождает занимаемое ими место. Это необходимо, чтобы вернуть пространство обратно системе и предотвратить раздувание таблиц (bloat). Некоторые функции VACUUM:
	Освобождение пространства 		— устаревшие строки помечаются как доступные для повторного использования.
	Обновление статистики 			— (с опцией ANALYZE) VACUUM обновляет статистику таблицы, используемую оптимизатором запросов для выбора эффективных планов выполнения.
	Обновление информации о видимости 	— VACUUM обновляет внутренние структуры данных (например, карту видимости) для ускорения будущих сканирований индексов.

------------------------------------ стадии VACUUM в PostgreSQL:
Инициализация 				— процедура определяет, какие таблицы и индексы нужно обработать, устанавливает точку входа для обработки данных и определяет параметры выполнения.
Сбор статистики 			— VACUUM собирает информацию о текущем состоянии таблиц и индексов, включая количество живых и мёртвых строк, размер таблиц и уровень фрагментации.
Анализ и маркировка 			— VACUUM анализирует страницы данных и отмечает мёртвые строки, которые следует удалить. На этом этапе могут обновляться карта видимости (VM) и карта свободного пространства (FSM).
Очистка таблицы 			— удаляются мёртвые строки, и освобождается пространство для новых данных.
Очистка индексов 			— индексы, связанные с таблицами, также очищаются от ссылок на удалённые строки. Если используется команда VACUUM FULL, индексы перестраиваются заново.
Обновление статистики и завершение 	— обновляются внутренние статистические данные, такие как карта видимости и карта свободного пространства. Записываются результаты выполнения процедуры, что помогает оптимизатору запросов более эффективно планировать будущие запросы.



==================================== AUTOVACUUM в PostgreSQL:
работает по таймеру по определённым критериям и порогам срабатывания.
autovacuum_max_workers = 10 			- количество параллельных процессов;
autovacuum_naptime = 15s 			- время сна между запусками процессов автовакуума;
autovacuum_vacuum_threshold = 25 		- минимальное количество измененных строк, при котором автовакуум придет в таблицу для очистки.

------------------------------------ FREEZE:
процесс, при котором процесс очистки (VACUUM) помечает достаточно старые версии строк как «замороженные». Это необходимо, чтобы обеспечить корректность работы даже после зацикливания идентификаторов транзакций (transaction id wraparound). Заморозка нужна, так как в PostgreSQL каждая строка содержит информацию о идентификаторе транзакции, которая её создала. Поскольку счётчик транзакций в СУБД 32-битный, старые идентификаторы должны быть использованы заново. Чтобы избежать неоднозначности, метаданные старых строк обновляются, чтобы отметить, что они заморожены, перед тем как их идентификаторы транзакций будут использованы заново. AUTOVACUUM находит достаточно старые и «холодные» версии строк (которые видны во всех снимках и изменение которых уже маловероятно) и специальным образом помечает их. Замороженная версия строки считается старше любых обычных данных и всегда видна во всех снимках данных. При этом уже не требуется смотреть на номер транзакции xmin, и этот номер может быть безопасно использован заново. 
Процесс заморозки может работать в двух режимах: 
Ленивый режим 		— сканирует только страницы, содержащие мёртвые строки.
Жадный режим 		— сканирует все страницы во всей таблице.




==================================== shared_memory:
Задаёт реализацию разделяемой памяти, которую сервер должен использовать для основной области разделяемой памяти, где хранятся общие буферы (shared_buffers) PostgreSQL и другие общие данные. Возможные значения: 
mmap 			для анонимной разделяемой памяти, выделенной с помощью mmap, 
sysv 			для разделяемой памяти System V, выделенной с помощью shmget
windows 		для разделяемой памяти Windows. 



==================================== shared_buffers:
объём памяти, выделенной сервером для совместного кеша страниц. Эта память разделяется между всеми процессами PostgreSQL. shared_buffers = 128MB by Default.
Особенности:
	-Данные загружаются в общий буфер сервера, серверные процессы читают и пишут блоки в этом буфере, а затем уже изменения сбрасываются на диск. 
	-Если объём буфера недостаточен для хранения частоиспользуемых рабочих данных, то они будут постоянно писаться и читаться из кэша ОС или с диска, что отрицательно скажется на производительности. 
	-Рекомендуется установить в пределах 25% от общего объёма оперативной памяти системы. Например, для сервера с RAM=100ГБ рекомендуемое значение — 25ГБ. 
	-Изменение этого параметра требует перезапуска сервера базы данных;
	-Page and Header:
		--Header-8KB (default) исменение размера возможно, но, только, при создании БД;
		--Page	




==================================== Хэш-таблица shared memory:
таблица, которая строится в общей динамически выделяемой памяти. 
Функция: 		хэш-таблица используется при соединениях и агрегировании по хешу, мемоизации узлов, а также обработке подзапросов IN с применением хеша. 
Особенности:
	-Данные в хэш-таблице хранятся в парах «ключ-значение».
	-Функция хеша распределяет ключи случайно и равномерно по ограниченному количеству buckets.
	-Объём памяти, выделенный для хэш-таблицы, определяется произведением work_mem и hash_mem_multiplier (по умолчанию — 1,0).
	-Хэш-таблица доступна всем параллельным процессам, что позволяет им выделять свой объём памяти для её построения, а не каждый процесс создаёт одну личную таблицу.



==================================== Victim page в PostgreSQL:
страница, которая выбирается буфер, который будет освобождён, для замены при управлении буферами. Это часть алгоритма CLOCK-sweep — лёгкого приближения алгоритма Least Recently Used (LRU) для замены страниц. Помогает и глаживает алгоритм процесс bgwriter и checkpoint.
Цель механизма 			— оптимизировать использование памяти: часто используемые страницы остаются в памяти дольше, а старые, менее используемые — постепенно вытесняются. 
Принцип работы			- Алгоритм CLOCK-sweep поддерживает круговой список (clock) страниц буфера. Каждая страница имеет счётчик использования — он отслеживает, как часто к ней обращались. При обращении к странице счётчик увеличивается, указывая на недавнее использование. 



==================================== bgwriter:
Background Writer в PostgreSQL — фоновый процесс, который записывает «грязные» (новые или изменённые) буферы в общей памяти на диск. Функции:			- 					- Периодически сбрасывает «грязные» данные из буфера памяти на диск, чтобы снизить блокировку во время запроса. 
				- Сбрасывает редко используемые «грязные» буферы на диск, освобождая буферный кэш для новых данных и облегчая нагрузку на диски при работе процесса контрольных точек. 
				- Находит те буферы, которые с большой вероятностью вскоре потребуется вытеснить, и записывает их на диск. За счёт этого обслуживающий процесс скорее всего обнаружит, что выбранный им буфер не является грязным. 


==================================== checkpoint:
момент в последовательности транзакций, когда все «грязные» страницы данных, находящиеся в памяти, сбрасываются на диск, а в файле WAL создаётся специальная запись контрольной точки. Цель checkpoint:
				- гарантировать, что все совершённые транзакции постоянно хранятся, чтобы избежать потери данных при сбое системы;
				- работать с механизмом восстановления базы данных: если произошёл сбой, PostgreSQL начинает обрабатывать журналы WAL, начиная с последней успешной контрольной точки.



==================================== isdirty в PostgreSQL
значение содержится в заголовке буфера, который представляет собой место под одну страницу данных (блок). Заголовок, в числе прочего, содержит:
	-расположение на диске страницы, находящейся в буфере (файл и номер блока в нём);
	-признак того, что данные на странице изменились;
	-число обращений к буферу (usage count);
	-признак закрепления буфера (pin count).
В PostgreSQL есть расширение pg_buffercache, которое позволяет отслеживать состояние буферного кэша, включая значение isdirty. Представление pg_buffercache позволяет отслеживать состояние буферного кэша в реальном времени. Для каждого буфера в общем кеше выдаётся одна строка, для неиспользуемых буферов все поля равны NULL, за исключением bufferid
t	-признак того, что данные на странице (буфере) изменились и рано или поздно должны быть записаны на диск.  страница загрязнена;
f	-логическое поле означает, что страница не загрязнена.


==================================== WAL - журналы:
WRITE AHEAD LOG -  журнал предзаписи. Это механизм, который обеспечивает долговечность и восстанавливаемость данных после сбоя. Механизм сохранения данных раньше, чем данные запишутся на диск HDD. Механизм позволяет восстановиться после сбоя. Принцип работы:
	-При изменении данных PostgreSQL формирует специальную запись в памяти — WAL-запись, данные записываются в журналы. Запись в журнале содержит всю необходимую информацию: тип операции, идентификатор транзакции, номер блока страницы, старые и новые значения; 
	-Запись попадает в специальный буфер в оперативной памяти — WAL buffer; 
	-По-умолчанию, при завершении успешной транзакции (COMMIT), происходит принудительная запись всех соответствующих WAL-записей на постоянное хранилище HDD — этот момент называется checkpoint; 
	-В случае сбоя записи данных в БД, процедура восстановления ищет последнюю запись контрольной точки, чтобы определить точку в WAL (запись REDO), от которой процедура должна начать операцию воспроизведения изменений из WAL-file. Любые изменения файлов данных до этой точки уже гарантированно находятся на диске. 
------------------------------------ Сегмент WAL:
в PostgreSQL — это файл, который представляет собой сегмент журнала упреждающей записи (Write-Ahead Logging, WAL). Стандартный размер сегмента — 16 МБ. Имя файла состоит из 24 шестнадцатеричных символов, которые кодируют уникальный идентификатор сегмента, включающий timeline ID, номер логической группы и номер файла. Хранится в каталоге pg_wal внутри основного каталога данных (data directory). 
------------------------------------ pg_wal:
Внутри pg_wal хранятся файлы с расширением .wal (или .partial, если файл ещё не завершён).
------------------------------------ LSN:
Log Sequence Number в PostgreSQL
уникальный идентификатор позиции в журнале предзаписи (WAL — Write-Ahead Logging). Это 64-битное число, которое представляет собой байтовое смещение до записи относительно начала журнала. LSN выводится в виде двух шестнадцатеричных чисел до 8 цифр каждое через косую черту, например: 16/B374D848. Размер одного LSN — 8 байт, что обеспечивает практически неограниченный диапазон значений для отслеживания изменений. Принцип работы:
	-Когда происходит изменение данных в PostgreSQL, система сначала записывает информацию об этом изменении в журнал WAL, присваивая ему уникальный LSN. Только после этого изменение применяется к основным данным. 
	-Система LSN работает по принципу возрастающей последовательности, где каждое новое значение больше предыдущего. Это позволяет PostgreSQL точно определять состояние базы данных в любой момент времени. 
	-Механизм LSN особенно важен при восстановлении после сбоев, репликации данных и выполнении точечных бэкапов. 


==================================== XACT "xact" в PostgreSQL:
структура, которая содержит информацию о статусах транзакций. До версии PostgreSQL 10 она называлась CLOG (commit log). В XACT для каждой транзакции отведено по два бита: по одному на каждый статус. Статус может иметь следующие значения: 
			транзакция стартовала, 
			транзакция успешно завершена, 
			транзакция отменена, 
			подтранзакция успешно завершена. 
------------------------------------ Принцип работы:
Информация в структуру XACT записывается в общей памяти. Это массив, который хранится в страницах размером по 8 КБ и содержит номер транзакции и её статус. Некоторые особенности работы:
	При фиксации транзакции в XACT выставляется бит 	committed для этой транзакции.
	При отмене транзакции в XACT выставляется бит 		aborted.
	Статус вложенных транзакций записывается обычным образом в XACT, но финальный статус зависит от статуса основной транзакции: если она отменена, то отменяются также и все вложенные транзакции.
==================================== Почему биты не устанавливаются самой транзакцией, выполняющей вставку?
когда происходит вставка, транзакция ещё не знает, завершится ли она успешно, а в момент фиксации уже непонятно, какие именно строки в каких именно страницах были изменены. 
------------------------------------ Хранение:
Данные XACT хранятся в каталоге PGDATA/pg_xact. Файлы в директории pg_xact именуются от 0000 до FFFF, максимальный размер такого файла — 256 КБ. 
В момент запуска PostgreSQL считывает информацию из этих файлов в структуру XACT в общей разделяемой памяти. 


==================================== как получить доступ к одному Объектов/Ресурсов, для изменений, во множестве транзакций?
Процесс начинает работу с Объектом/Ресурсом, установив его блокировку. Блокировка, занятого Ресурса/Объекта одним из процессов, - для других процессов, поэтому возникают очереди. Работа с очередями решается:
		-Multiversion Concurrency Control;
		-Оптимистические блокировки в PostgreSQL — это стратегия блокировки, основанная на предположении, что конфликты случаются редко. Вместо того чтобы сразу блокировать данные, система разрешает свободный доступ и проверяет, не изменились ли данные, только в момент сохранения.

------------------------------------ Ресурсы/Объекты:
Объекты:
	таблицы (отношения);
	индексы;
	последовательности;
	материализованные представления;
	страницы данных (идентифицируются именем файла и позицией внутри файла);
	табличные строки (страница и смещение внутри страницы).
Ресурсы:
	идентифицируемые заранее присвоенным номером:
		хэш-таблицы,
		буферы,
	абстрактные ресурсы, не имеющие физического смысла:
		идентифицируются просто уникальным числом

==================================== Блокировки:
------------------------------------ Гранулярность блокировки в PostgreSQL:
степень детализации блокировки, то, какой объём данных «захватывается» при блокировании. Гранулярность важна, если ресурсы образуют иерархию, например, таблица состоит из страниц, которые содержат версии строк. Чем выше гранулярность, тем больше возможностей для распараллеливания, но это приводит к увеличению числа блокировок, информацию о которых надо где-то хранить. В PostgreSQL используются блокировки на разных уровнях гранулярности: 
	На уровне ТАБЛИЦ 			—блокируют всю таблицу. Если транзакция A начала изменение таблицы, транзакция B вынуждена ждать завершения A, даже если они затрагивают разные строки. 
	На уровне СТРОК 			—блокируют конкретные строки, затрагиваемые операцией (UPDATE/DELETE/SELECT … FOR UPDATE), вместо всей таблицы. Это позволяет разным транзакциям одновременно изменять разные строки в одной таблице без конфликтов. 
	На уровне СТРАНИЦ 			—исключительные и разделяемые блокировки используются для управления доступом к страницам таблиц в общем пуле буферов. Эти блокировки снимаются немедленно после выборки или обновления строки.

------------------------------------ Виды блокировок:
EXCLUSIVE
SHARED			на доли секунд в shared buffers и ДБ;
ДОЛГОВРЕМЕННЫЕ		до конца транзакции в shared memory.
*-матрица совместимости в презентации.
		
1/	блокировки ОТНОШЕНИЙ операций
2/	блокировки СТРОК на диске
*-матрица совместимости в презентации.	
3/ 	блокировки ПАМЯТИ: 
			SPINLOCK не имеют мониторинга.
			LIGHTWEIGHTLOCK, случайный процесс
			BUFFERPIN

------------------------------------ deadlock:
ситуация, когда две или более транзакции ожидают освобождения ресурсов, заблокированных друг другом. Это создаёт циклическую зависимость, которую ни одна из транзакций не может разрешить самостоятельно. Когда несколько ПРОЦЕССОВ находятся в бесконечном ожидании ресурсов, захваченных самим этими ПРОЦЕССАМИ. Причины:
Неправильный порядок блокировок. 		транзакции блокируют строки в разных порядках, что создаёт циклическую зависимость; 
Длинные транзакции 				они удерживают блокировки на длительный период; 
Высокая конкурентность				многие одновременные транзакции увеличивают вероятность конфликтов блокировок; 
Ограничения на внешние ключи			операции, которые вызывают каскадные обновления или удаления.
Postgres строит граф связей. Обнаружив deadlock, Postgres разрывает взаимозависимости.