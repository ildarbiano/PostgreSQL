=============================== РЕЗЕРВНОЕ КОПИРОВАНИЕ:
Backup или архив или резервная копия - создание и хранение копий данных в другом месте, с определёнными целями:
При отказе основного сервера, можем восстановиться из архива	-отказоустойчивость;
Возможность развернуть отдельный тестовый сервер		-клонирование, создание тестового стенда;
Перенос инфраструктуры в другое место				-!
Обновлять версии Postgres					-!


=============================== РЕЗЕРВНОЕ КОПИРОВАНИЕ. ЛОГИЧЕСКОЕ:
набор текстовых файлов, извлеченных из БД по определенным правилам.
	+ можно сделать копию отдельного объекта или базы;
	+ можно восстановиться на кластере другой основной версии Postgres;
	+ можно восстановиться на другой архитектуре (Windows, Linux);
	+ для миграции данных между различными СУБД, взяв за основу и переделав содержимое, под формат той или иной СУБД ;
	− невысокая скорость относительно физической, так как текстовый файл (большой объём, структура).
------------------------------ ЛОГИЧЕСКОЕ АРХИВИРОВАНИЕ С ПОМОЩЬЮ УТИЛИТЫ COPY:
COPY { имя_таблицы [ ( имя_столбца [, ...] ) ] | ( запрос ) }  
TO { 'имя_файла' | PROGRAM 'команда' | STDOUT }  [ [ WITH ] ( параметр [, ...] ) ]
------
COPY имя_таблицы [ ( имя_столбца [, ...] ) ]  
FROM { 'имя_файла' | PROGRAM 'команда' | STDIN }  [ [ WITH ] ( параметр [, ...] ) ]
----------- For Server-Side Export:
COPY [Table/Query] to '[Absolute Path/filename.csv]' csv header;	-копирует по абсолютному пути на сервере Postgres. То есть, в ситуации запуска, когда запускается на клиентской машине, то копия создастся на сервере Postgres.
----------- For Client-Side Export (psql):
\copy [Table/Query] to '[Relative Path/filename.csv]' csv header	-копирует рядом с собой. Метакоманда \copy вызывает COPY FROM STDIN или COPY TO STDOUT, а затем работает с данными в файле, доступном клиенту psql. 
То есть, в ситуации запуска, когда запускается на клиентской машине, то копия создастся на клиентской машине. Таким образом, когда применяется команда \copy, доступность файла и права доступа зависят от клиента, а не от сервера.
------------------------------ ЛОГИЧЕСКОЕ АРХИВИРОВАНИЕ С ПОМОЩЬЮ УТИЛИТЫ PG_DUMP:
-выдает на консоль или в файл, либо SQL-скрипт, либо архив, в специальном формате с оглавлением;
-поддерживает параллельное выполнение;
-позволяет ограничить набор выгружаемых объектов:
	таблицы 	--table, 
	схемы 		--schema-only, 
	данные 		--data-only и т.п.
!!!!!!!!!!!!! по умолчанию не создает tablespace и users, то есть backup tablespace и users не предусмотрен !!!!!!!!!!!!!!!!!!!!!!!! Они должны быть созданы заранее.
$ pg_dump -d backup --create 					–вывод на экран.
$ pg_dump -d backup --create > 1.sql				-в файл.
------------------------------ ВОССТАНОВЛЕНИЕ ИЗ ЛОГИЧЕСКОГО АРХИВА:
Восстановление - psql, так как это простой SQL скрипт
$ psql < 1.sql
!!!!!!!!!!!!! заранее должны быть созданы Data Base, Users Roles и Tablespaces;
-позволяет ограничить набор объектов при восстановлении;
-поддерживает параллельное выполнение;
-после восстановления имеет смысл выполнить сбор статистики (ANALIZE)



=============================== РЕЗЕРВНОЕ КОПИРОВАНИЕ. ФИЗИЧЕСКОЕ:
бинарные копии файлов данных. Используется механизм восстановления после сбоя: копия данных и журналы предзаписи.
	+ скорость восстановления;
	+ можно восстановить кластер на определенный момент времени - point_in_time_recovery - PITR;
	− нельзя восстановить отдельную базу данных, только весь кластер;
	− восстановление только на той же основной версии и архитектуре.
------------------------------ Холодное РЕЗЕРВНОЕ КОПИРОВАНИЕ. COLD-backup:
Практически никогда не возможен, потому как требует чтобы БД была остановлена:
	*сервер корректно остановлен (потребуются файлы данных, только);
	*сервер НЕкорректно выключен (потребуются файлы данных и WAL-сегменты, для согласования данных).
------------------------------ Горячее РЕЗЕРВНОЕ КОПИРОВАНИЕ. HOT-backup:
на работающем экземпляре:
	*необходимы как файлы данных, так и WAL-сегменты, причем нужно проконтролировать, чтобы сервер сохранил все WAL-сегменты/файлы, на время копирования основных данных;
	*есть еще вариант snapshot как в linux, так и в hypervisor - оставим это для курса devops.
------------------------------ СОЗДАНИЕ АВТОНОМНОЙ КОПИИ. pg_basebackup:
Автономная копия содержит и файлы данных, и WAL. Создаётся утилитой pg_basebackup.
$ pg_createcluster 14 main2					-Создадим 2 кластер
$ rm -rf /var/lib/postgresql/14/main2				-Удалим оттуда файлы
$ pg_basebackup -p 5432 -D /var/lib/postgresql/14/main2		-Сделаем backup нашей БД (запуск на вторичном сервере, если другой хост то -h и настройка в pg_hba доступа по слоту репликации)
$ pg_ctlcluster 14 main2 start					-Стартуем кластер
$ pg_lsclusters							-Смотрим как стартовал

------------------------------ Резервное копирование:
утилита pg_basebackup:
	1/подключается к серверу по протоколу репликации;
	2/выполняет контрольную точку;
	3/переключается на следующий сегмент WAL;
	4/копирует файловую систему в указанный каталог;
	5/переключается на следующий сегмент WAL;
	6/сохраняет все сегменты WAL, сгенерированные за время копирования.
------------------------------ Восстановление:
	1/разворачиваем созданную автономную копию;
	2/запускаем сервер. Сервер восстанавлиявает согласованность.


=============================== РЕПЛИКАЦИИ в Postgres:
	* механизм синхронизации содержимого нескольких копий объекта (например, содержимого базы данных). 
	* процесс, под которым понимается копирование данных из одного источника на другой (или на множество других) и/или наоборот.
****при репликации изменения, сделанные в одной копии объекта, могут быть распространены в другие копии.
ФИЗИЧЕСКАЯ 		-полностью применяется весь поток изменений без разбора в одну сторону. Физическая двоичная копия кластера. HOT-backup;
ЛОГИЧЕСКАЯ 		-более расширенный поток данных и можно реплицировать конкретный обьект, например, таблицу. Поток репликации может быть двунаправленной.
	+ Высокая доступность. backup это хорошо, но нужно время на его развертывание. Реплика находится в Standby, поэтому переключение происходит несопоставимо быстрее;
	+ Что делать, когда закончились физические ядра и память у сервера? горизонтально масштабировать! Запись в master-cluster, а чиение с Реплик-slave-cluster;
	+ backup - является нагрузкой на сервер, поэтому лучше делать с реплики-slave-cluster, а не master-cluster;
	+ Геораспределение нагрузки. Сервера в разных геолокациях;
	+ Нагрузку по чтению и отчетам можно переложить на реплики, чтобы разгрузить основной сервер с master-cluster.
=============================== ФИЗИЧЕСКАЯ репликация. pg_basebackup:
Master-slave репликация в PostgreSQL 		— это архитектура репликации данных, при которой один сервер базы данных действует как мастер (главный), а один или несколько других серверов работают как реплики (подчинённые). 
Особенности физической репликации:
* master-slave: поток данных только в одну сторону;
* трансляция потока журнальных записей или файлов журнала;
* требуется двоичная совместимость серверов;
* возможна репликация только всего кластера.
------------------------------ pg_basebackup:
1/ создаем новый кластер;
2/ удаляем из него каталог с данными;
3/ разворачиваем резервную копию с ключом -R (Recovery);
4/ запускаем новый сервер.
5/ после физического резервирования продолжаем принимать журнальные файлы. ключ -R создаёт управляющий файл в котором прописаны данные основного сервера, откуда забирать WAL-файлы.
------------------------- Допускаются на реплике-slave-cluster:
*-запросы на чтение данных 	(select, copy to, курсоры);
*-установка параметров сервера 	(set, reset);
*-управление транзакциями 	(begin, commit, rollback...);
*-создание резервной копии 	(pg_basebackup).
------------------------- НЕ допускаются на slave-cluster, только на master-cluster:
*-любые изменения 		(insert, update, delete, truncate, nextval...);
*-блокировки, предполагающие изменение (select for update...);
*-команды DDL (create, drop...), в том числе создание временных таблиц;
*-команды сопровождения 	(vacuum, analyze, reindex...);
*-управление доступом 		(grant, revoke...);
*-не срабатывают триггеры.


=============================== ЛОГИЧЕСКАЯ репликация:
*-Концепция по ролям: "Поставщик-"Подписчик": поток данных возможен в обе стороны. При логической репликации у сервера нет выделенной роли мастера или реплики, что позволяет организовать в том числе и двунаправленную репликацию:
	*-делается публикация объектов;
	*-подписываемся на них из других кластеров/clusters;
	*-получаем изменения в объектах. 
*-информация о строках (уровень WAL-журнала: wal_level=logical). Для передачи логических изменений (на уровне строк) используется протокол репликации. Для работы такой репликации требуется установка уровня журнала wal_level=logical;
*-требуется совместимость на уровне протокола, то есть:
	*-Возможна репликация -------------между разными основными версиями Postgres;
	*-Возможна выборочная репликация --отдельных таблиц.
------------------------------ альтернативы:
-Встроенная логическая репликация доступна в версиях PostgreSQL, начиная с 10. Для более ранних версий аналогичный функционал доступен в расширении pg_logical.
-Другой способ организации логической репликации состоит в использовании триггеров (программ) для перехвата изменений, помещения этой информации в очередь событий и передача ее на другой сервер. Такой способ, однако, менее эффективен, и уходит в прошлое (Slony-I).
------------------------------ логическая репликация. ПРИНЦИП РАБОТЫ:
ПУБЛИКУЮЩИЙ СЕРВЕР:
	-выдает изменения данных по-строчно, в порядке их фиксации. Реплицируются команды: INSERT, UPDATE, DELETE, + в 11 версии добавили TRUNCATE. Остальные DML-команды (select, merge), а также DDL-команды (создания и изменения структур баз данных) - не передаются;
	-возможна начальная синхронизация;
	-всегда используется слот логической репликации (=10слотов), для работы протокола;
	-DDL*7.Индексы - не передаются, то есть таблицы-приемники на стороне подписчика надо создавать вручную;
	-Данные последовательностей не реплицируются;
	-Реплицировать данные возможно только из базовых таблиц в базовые таблицы. *-то есть, таблицы на стороне публикации и на стороне подписки должны быть обычными, а не view, materialized view, tables partitioning или foreign tables;
	-применение изменений происходит без выполнения команд SQL, и связанных с этим накладных расходов на разбор и планирование (пришедшая точка с данными записывается поверх существующей), что уменьшает нагрузку CPU, - на подписчика;
	-параметр wal_level = logical.
ПОДПИСЧИКИ:
	-получают и применяют изменения:
		-без разбора, трансформаций и планирования — сразу выполнение;
	-возможны конфликты с локальными данными. Конфликты устраняются вручную;
	-триггеры (при физической репликации не работают) срабатывают для каждого подписчика отдельно.
------------------------------ логическая репликация. ОСОБЕННОСТИ:
Режимы идентификации для изменения и удаления:
	-столбцы первичного ключа (по умолчанию);
	-столбцы указанного уникального индекса с ограничением NOT NULL (*index);
	-все столбцы;
	-без идентификации (по умолчанию для системного каталога, system view).
Конфликты — нарушение ограничений целостности:
	-репликация приостанавливается до устранения конфликта вручную:
		-либо исправление данных;
		-либо пропуск конфликтующей транзакции.








